## Plot performance assessment matrix#### Usage: tool_plot_perfassmat(p_ah, p_vm, p_vl, p_bc, p_fc, p_bw, p_lm)#### p_ah ... axes handle, <dbl>## p_vm ... value matrix [Nrow x Ncol]; [[<dbl>]]## p_vl ... value limit(s), dual state [1 x 1], triple state [1 x 2], [<dbl>]## p_bc ... background colors, dual state [2 x 3], triple state [3 x 3], [<dbl]## p_fc ... foreground colors, dual state [2 x 3], triple state [3 x 3], [<dbl]## p_bw ... cell box width, equal width/height [1 x 1], userdefined width/height [1 x 2], <dbl> or [<dbl>]## p_lm ... label mode, see below, <str>#### Label modes:##   p_lm = 'val': plot matrix values, p_fc(2,:) for values above limit, p_fc(1,:) for values below or equal to limit##   p_lm = 'valinv': plot matrix values, p_fc(1,:) for values above limit, p_fc(2,:) for values below or equal to limit##   p_lm = 'mark': plot cross for values above limit, plot checkmark for values below limit##   p_lm = 'markinv': plot checkmark for values above limit, plot cross for values below limit##   p_lm = 'yn': plot 'no' for values above limit, plot 'yes' for values below limit##   p_lm = 'yninv': plot 'yes' for values above limit, plot 'no' for values below limit##   p_lm = 'YN': plot 'N' for values above limit, plot 'Y' for values below limit##   p_lm = 'YNinv': plot 'Y' for values above limit, plot 'N' for values below limit##   p_lm = 'tf': plot 'true' for values above limit, plot 'false' for values below limit##   p_lm = 'tfinv': plot 'false' for values above limit, plot 'true' for values below limit##   p_lm = 'TF': plot 'F' for values above limit, plot 'T' for values below limit##   p_lm = 'TFinv': plot 'T' for values above limit, plot 'F' for values below limit##   p_lm = 'none': do not plot matrix values#### Note: This command can only be used inside a "hold environment".##       Example:##         hold on;##         tool_plot_perfassmat(p_ah, p_vm, p_vl, p_bc, p_fc, p_bw, p_lm);##         hold off;#### Signal model: see tool_gen_sinusoidal1#### see also: tool_gen_sinusoidal1, tool_scale_noise2snr, tool_est_acfrn########################################################################################################################### LICENSE####    Copyright (C) 2024 Jakob Harden (jakob.harden@tugraz.at, Graz University of Technology, Graz, Austria)####    This program is free software: you can redistribute it and/or modify##    it under the terms of the GNU Affero General Public License as##    published by the Free Software Foundation, either version 3 of the##    License, or (at your option) any later version.####    This program is distributed in the hope that it will be useful,##    but WITHOUT ANY WARRANTY; without even the implied warranty of##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the##    GNU Affero General Public License for more details.####    You should have received a copy of the GNU Affero General Public License##    along with this program.  If not, see <https://www.gnu.org/licenses/>.########################################################################################################################### This file is part of the PhD thesis of Jakob Harden.##function tool_plot_perfassmat(p_ah, p_vm, p_vl, p_bc, p_fc, p_bw, p_lm)    ## check arguments  if (nargin < 7)    p_lm = [];  endif  if (nargin < 6)    p_bw = [];  endif  if (nargin < 5)    p_fc = [];
  endif  if (nargin < 4)    p_bc = [];
  endif  if (nargin < 3)    p_vl = [];
  endif  if (nargin < 2)    help tool_plot_perfassmat;    error('Less arguments given!');  endif    ## setup value limits  if isempty(p_vl)    p_vl = min(min(p_vm)) + range(range(p_vm)) * 0.5; # dual state assessment  endif    ## setup label mode  if isempty(p_lm)    p_lm = 'none';
  endif    ## setup box width
  if isempty(p_bw)    p_bw = [1, 1] * 0.8;
  endif    ## setup forground colors, label colors  if isempty(p_fc)    if (numel(p_vl) == 1)      p_fc = [[0.0, 1, 0.0]; [1, 0.0, 0.0]]; # green/red    else      p_fc = [[0.0, 1, 0.0]; [1, 0.65, 0.0]; [1, 0.0, 0.0]]; # green/red/orange (traffic light protocol)    endif  endif  if (size(p_fc, 1) != numel(p_vl) + 1)    error('Less foreground colors given! Number of colors must match number of limits plus 1.');
  endif  if (numel(p_vl) == 1)    p_fc = [p_fc(1, :); [0, 0, 0]; p_fc(2, :)];  endif
    ## setup background colors, fill colors
  if isempty(p_bc)    if (numel(p_vl) == 1)      p_bc = [[0.8, 1, 0.8]; [1, 0.8, 0.8]]; # green/red    else      p_bc = [[0.8, 1, 0.8]; [1, 0.86, 0.73]; [1, 0.8, 0.8]]; # green/orange/red (traffic light protocol)    endif  elseif (size(p_bc, 1) < numel(p_vl) + 1)    error('Less background colors given! Number of colors must match number of limits plus 1.');  endif  if (numel(p_vl) == 1)    p_bc = [p_bc(1, :); [1, 1, 1]; p_bc(2, :)];  endif    ## setup figure and axes handle  if isempty(p_ah)    fh = figure('name', 'Assessment matrix');    p_ah = axes(fh);  endif    ## switch label mode  lv = cell(size(p_vm)); # label values  lc = cell(size(p_vm)); # label colors  bc = cell(size(p_vm)); # background colors  for j = 1 : size(p_vm, 1)    for k = 1 : size(p_vm, 2)
      switch (p_lm)        case 'val'          ## plot values          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, true);          tmpstr = sprintf('%.1f', p_vm(j, k));          opts = {tmpstr, tmpstr, tmpstr};        case 'valinv'          ## plot values, inverse          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, false);          tmpstr = sprintf('%.1f', p_vm(j, k));          opts = {tmpstr, tmpstr, tmpstr};
        case 'mark'          ## plot checkmark or cross          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, true);          opts = {'√', '~', 'x'};        case 'markinv'          ## plot checkmark or cross, inverse          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, false);          opts = {'√', '~', 'x'};        case 'yn'          ## plot yes/no          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, true);          opts = {'yes', '~', 'no'};        case 'yninv'          ## plot yes/no, inverse          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, false);          opts = {'yes', '~', 'no'};        case 'YN'          ## plot Y/N          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, true);          opts = {'Y', '~', 'N'};        case 'YNinv'          ## plot Y/N, inverse          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, false);          opts = {'Y', '~', 'N'};        case 'tf'          ## plot true/false          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, true);          opts = {'true', '~', 'false'};        case 'tfinv'          ## plot true/false, inverse          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, false);          opts = {'true', '~', 'false'};        case 'TF'          ## plot T/F          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, true);          opts = {'T', '~', 'F'};        case 'TFinv'          ## plot T/F, inverse          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, false);          opts = {'T', '~', 'F'};        otherwise          ## do not plot cell values          idx = tool_plot_perfassmat_perfstate(p_vm(j, k), p_vl, true);          opts = {' ', ' ', ' '};
      endswitch      lv(j, k) = opts{idx}; # label string      lc(j, k) = p_fc(idx, :); # label color      bc(j, k) = p_bc(idx, :); # fill color    endfor  endfor    ## geometry settings  dx = p_bw(1); dx2 = dx / 2; dx4 = dx / 4;  dy = p_bw(2); dy2 = dy / 2; dy4 = dy / 4;    ## iterate over rows  for j = 1 : size(p_vm, 1)    ## iterate over columns    for k = 1 : size(p_vm, 2)      ## handle visibility      if ((j == 1) && (k == 1))        hvis = 'on';      else        hvis = 'off';      endif      ## rectangle position      rx = k - dx2; ry = -j - dy2; rw = dx; rh = dy;      ## plot rectangle      rectangle(p_ah, 'position', [rx, ry, rw, rh], 'linestyle', 'none', 'facecolor', bc{j, k}, 'handlevisibility', hvis);      ## plot label      text(p_ah, k, -j, lv{j, k}, 'color', lc{j, k}, 'horizontalalignment', 'center', 'verticalalignment', 'middle');    endfor  endfor  endfunctionfunction [r_s] = tool_plot_perfassmat_perfstate(p_v, p_l, p_i)  ## Performance state assessment  ##  ## p_v ... value to be checked, <dbl>  ## p_l ... limit(s), <dbl> or [<dbl>]  ## p_i ... inverse mode status, true/false, <bool>  ## r_s ... return: performance state, <uint>  ##  ## Note: if p_l consists of 2 elements, perform a triple state assesment    r_s = 0;  if (numel(p_l) == 1)    ## dual state    if (p_v > p_l)      if (p_i)        r_s = 3;      else        r_s = 1;      endif
    else      if (p_i)        r_s = 1;      else        r_s = 3;      endif    endif
  else    ## triple state    if (p_i)      ## forward assessment      r_s = 1; # default, below lower limit      if (p_v > p_l(1))        ## above lower limit        r_s = 2;      endif      if (p_v > p_l(2))        ## above higher limit        r_s = 3;      endif
    else      ## inverse assessment      r_s = 3; # default, below higher limit      if (p_v > p_l(1))        ## above lower limit        r_s = 2;      endif      if (p_v > p_l(2))        ## above higher limit        r_s = 1;      endif    endif
  endif
  endfunction